// Minimal ColorQuest prototype (Canvas)// Controls: ← → or A/D, Space to jump, 1/2/3 to change colorsconst canvas = document.getElementById('game');const ctx = canvas.getContext('2d');const HUD = {  dot: document.getElementById('color-dot'),  name: document.getElementById('color-name')};const COLORS = [  {id:'red',   color:'#e74c3c'},  {id:'green', color:'#2ecc71'},  {id:'blue',  color:'#3498db'}];let keys = {};window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; keyPress(e); });window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);function keyPress(e){  if(e.key === '1') setActiveColor(0);  if(e.key === '2') setActiveColor(1);  if(e.key === '3') setActiveColor(2);}let activeColorIndex = 0;function setActiveColor(i){  activeColorIndex = i;  HUD.dot.style.background = COLORS[i].color;  HUD.name.textContent = COLORS[i].id.charAt(0).toUpperCase() + COLORS[i].id.slice(1);}// Worldconst world = {  gravity: 1200,  friction: 0.9,  platforms: [    // ground    {x:0,y:500,w:960,h:40,color:'neutral'},    // red platform (solid only when player is red)    {x:200,y:380,w:160,h:20,color:'red'},    // green platform    {x:420,y:300,w:160,h:20,color:'green'},    // blue platform    {x:640,y:380,w:160,h:20,color:'blue'},    // exit zone    {x:880,y:440,w:60,h:60,color:'exit'}  ]};// Playerconst player = {  x:60, y:440, w:28, h:40,  vx:0, vy:0,  speed: 280,  jumpStrength: 460,  onGround: false,  colorIndex: 0};function rectsOverlap(a,b){  return a.x < b.x + b.w &&         a.x + a.w > b.x &&         a.y < b.y + b.h &&         a.y + a.h > b.y;}// Simulate simple physics and collisionsfunction update(dt){  // color state follows active HUD color  player.colorIndex = activeColorIndex;  // input  let left = keys['arrowleft'] || keys['a'];  let right = keys['arrowright'] || keys['d'];  if(left) player.vx = -player.speed;  else if(right) player.vx = player.speed;  else player.vx = 0;  if((keys[' '] || keys['space']) && player.onGround){    player.vy = -player.jumpStrength;    player.onGround = false;  }  // gravity  player.vy += world.gravity * dt;  // apply velocity  player.x += player.vx * dt;  player.y += player.vy * dt;  // simple bounds  if(player.x < 0) player.x = 0;  if(player.x + player.w > canvas.width) player.x = canvas.width - player.w;  // collision with platforms  player.onGround = false;  for(let p of world.platforms){    // special: exit    if(p.color === 'exit' && rectsOverlap(player,p)){      // reached exit: reset and small notification      alert('Level complete! (prototype)');      resetPlayer();      break;    }    // neutral platforms always solid    let solid = p.color === 'neutral' || COLORS[player.colorIndex].id === p.color;    if(!solid) continue;    // Axis-aligned collision resolution (very simple)    const px = {x:player.x, y:player.y, w:player.w, h:player.h};    const plat = {x:p.x, y:p.y, w:p.w, h:p.h};    if(rectsOverlap(px, plat)){      // determine penetration on Y      const penDown = (px.y + px.h) - plat.y;      const penUp = (plat.y + plat.h) - px.y;      const penRight = (px.x + px.w) - plat.x;      const penLeft = (plat.x + plat.w) - px.x;      const minPen = Math.min(penDown, penUp, penRight, penLeft);      if(minPen === penDown){        // player hit top of platform => stand        player.y -= penDown;        player.vy = 0;        player.onGround = true;      } else if(minPen === penUp){        // hit from below        player.y += penUp;        player.vy = 0;      } else if(minPen === penRight){        player.x -= penRight;        player.vx = 0;      } else {        player.x += penLeft;        player.vx = 0;      }    }  }  // small floor fallback  if(player.y + player.h > canvas.height){    player.y = canvas.height - player.h;    player.vy = 0;    player.onGround = true;  }}// Renderfunction draw(){  ctx.clearRect(0,0,canvas.width,canvas.height);  // draw background grid  ctx.fillStyle = '#0f1720';  ctx.fillRect(0,0,canvas.width,canvas.height);  // draw platforms  for(let p of world.platforms){    if(p.color === 'neutral'){      ctx.fillStyle = '#6b7178';      ctx.fillRect(p.x, p.y, p.w, p.h);    } else if(p.color === 'exit'){      ctx.fillStyle = '#f1c40f';      ctx.fillRect(p.x, p.y, p.w, p.h);      ctx.fillStyle = '#111';      ctx.font = '12px sans-serif';      ctx.fillText('EXIT', p.x+8, p.y+36);    } else {      // colored platforms show active/inactive state      const idx = COLORS.findIndex(c => c.id === p.color);      const active = idx === player.colorIndex;      const baseColor = COLORS[idx].color;      ctx.fillStyle = active ? baseColor : desaturate(baseColor, 0.3);      ctx.fillRect(p.x, p.y, p.w, p.h);      // outline to help colorblind      ctx.strokeStyle = '#0a0a0a';      ctx.strokeRect(p.x, p.y, p.w, p.h);      // shape icon for accessibility      ctx.fillStyle = active ? '#fff' : '#111';      ctx.font = '14px sans-serif';      const icon = idx === 0 ? '■' : idx === 1 ? '●' : '◆';      ctx.fillText(icon, p.x + 6, p.y + 14);    }  }  // draw player with colored overlay  ctx.fillStyle = '#ffffff';  ctx.fillRect(player.x, player.y, player.w, player.h);  ctx.fillStyle = COLORS[player.colorIndex].color;  ctx.globalAlpha = 0.35;  ctx.fillRect(player.x, player.y, player.w, player.h);  ctx.globalAlpha = 1.0;  // ground shadow  ctx.fillStyle = 'rgba(0,0,0,0.12)';  ctx.fillRect(0, 520, canvas.width, 20);}// simple color desaturate helperfunction desaturate(hex, amt){  // hex to rgb  const bigint = parseInt(hex.replace('#',''),16);  let r = (bigint >> 16) & 255;  let g = (bigint >> 8) & 255;  let b = bigint & 255;  // lerp towards gray  const gray = (r+g+b)/3;  r = Math.round(r*(1-amt) + gray*amt);  g = Math.round(g*(1-amt) + gray*amt);  b = Math.round(b*(1-amt) + gray*amt);  return `rgb(${r},${g},${b})`;}let last = performance.now();function loop(now){  const dt = Math.min(0.032, (now - last)/1000);  update(dt);  draw();  last = now;  requestAnimationFrame(loop);}function resetPlayer(){  player.x = 60; player.y = 440; player.vx = 0; player.vy = 0;}setActiveColor(0);resetPlayer();requestAnimationFrame(loop);
